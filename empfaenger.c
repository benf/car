//#define F_CPU 16000000UL
#define F_CPU  1000000UL

#include <avr/io.h>
#include <avr/interrupt.h>
#include <stdint.h>
#include <util/delay.h>
#include <util/crc16.h>

#include "rf12_cfg.h"
#include "rfxx.h"

#include "sensor.h"
#include "control.h"

volatile uint8_t id = 0;

ISR (TIMER0_OVF_vect)
{
	cli();
	sensor_irq();
	sei();
}

/*! TODO: interupt: Wof√ºr die dieser interupt?  */
ISR (INT2_vect) {

	cli();
	PORTC ^= (1 << PC2);

	uint8_t data = rf12_recv();

	PORTC &= ~(1 << PC4);

	switch (id) {
		case 0:
			action = data;
			id = 1;
			break;
		// parameter for command
		case 1:
			param = data;
			id = 2;
			break;
		case 2: // checksum
			if (data == _crc_ibutton_update(_crc_ibutton_update(0, action), param))
				control_cmd(action,param);
			id = 0;
			rfxx_wrt_cmd(0xCA81); // reset fifo
			rfxx_wrt_cmd(0xCA83); //  - || -
			PORTC |= (1 << PC4);

			break;
	}
	sei();
}

int main(void)
{
	/* wait 300ms to give the rf12's POR (Power-On Reset) time to
	 * initialize the registers etc.. (initializing wouldnt work without)
	 *
	 * .. this is NOT documented in the datasheet :\
	 *
	 * notice:
	 *  the producer did the same in the example code but let it uncommented
	 *
	 * TODO: try avoid waiting 300ms by using the interrupt generated by POR
	 *       disadvantage: IRQ will lengthen (IRQ on INT0) 
	 */

	// engine ctrl led and reset indicator
	DDRC  |=  (1 << DDC1);
	PORTC |=  (1 << PC1);

	_delay_ms(400);

	rfxx_init();
	rf12_init(0);

	// things just needed for debugging
	//DDRA = 0xff;

	init_sensor();
	init_control();

	// enable external interrupt 2
	GICR  = (1 << INT2);
	
	// Interrupt PIN = Input
	RFXX_nIRQ_PORT &= ~(1 << RFXX_nIRQ);

	// enable receiver's FIFO
	rfxx_wrt_cmd(0xCA83);


	DDRC  |=  (1 << DDC5);
	PORTC |=  (1 << PC5);

	// enable interrupts (global)
	sei();

	PORTC &=  ~(1 << PC1);

	while (1);
}

/* vim: set sts=0 fenc=utf-8: */
